"use strict";(self.webpackChunk_okp4_docs=self.webpackChunk_okp4_docs||[]).push([[41038],{45914:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>t,metadata:()=>o,readingTime:()=>c,toc:()=>d});var i=s(85893),a=s(11151);const t={sidebar_class_name:"hidden"},r="Define any rule",o={id:"academy/rules",title:"Define any rule",description:"Reading time:  min",source:"@site/docs/academy/rules.md",sourceDirName:"academy",slug:"/academy/rules",permalink:"/academy/rules",draft:!1,unlisted:!1,editUrl:"https://github.com/okp4/docs/edit/main/docs/academy/rules.md",tags:[],version:"current",frontMatter:{sidebar_class_name:"hidden"},sidebar:"mainSidebar",previous:{title:"Resources: what can be shared",permalink:"/academy/resources"},next:{title:"OKP4 NFT tutorial",permalink:"/nft-tutorial/en"}},l={},c=12,d=[{value:"Rules: what can be defined?",id:"rules-what-can-be-defined",level:2},{value:"1. Defining Access Permissions",id:"1-defining-access-permissions",level:3},{value:"2. Resource Utilization Policies",id:"2-resource-utilization-policies",level:3},{value:"3. Business models",id:"3-business-models",level:3},{value:"4. Dynamic Rule Updates",id:"4-dynamic-rule-updates",level:3},{value:"5. Inter-Rule Relationships",id:"5-inter-rule-relationships",level:3},{value:"Prolog: Turing complete logical and declarative programming language",id:"prolog-turing-complete-logical-and-declarative-programming-language",level:2},{value:"1. The Essence of Prolog",id:"1-the-essence-of-prolog",level:3},{value:"2. Turing Completeness",id:"2-turing-completeness",level:3},{value:"3. Declarative Programming in Action",id:"3-declarative-programming-in-action",level:3},{value:"4. Logical Problem Solving",id:"4-logical-problem-solving",level:3},{value:"5. Decentralized Interpretation",id:"5-decentralized-interpretation",level:3},{value:"6. Prolog in practice",id:"6-prolog-in-practice",level:3},{value:"Resource&#39;s consents",id:"resources-consents",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"define-any-rule",children:"Define any rule"}),"\n",(0,i.jsxs)("i",{children:["Reading time: ",c," min"]}),"\n",(0,i.jsx)(n.h2,{id:"rules-what-can-be-defined",children:"Rules: what can be defined?"}),"\n",(0,i.jsxs)(n.p,{children:["The key feature of the OKP4 protocol is the ability to define rules within its ecosystem. The term ",(0,i.jsx)(n.strong,{children:'"Rules"'})," form the backbone of the protocol, governing how off-chain digital resources like datasets, algorithms, storage, and computation resources are shared and managed. These rules define the parameters and conditions under which resource sharing and interactions occur. Understanding the scope of what can be defined within these rules is crucial for harnessing the full power of the OKP4 protocol."]}),"\n",(0,i.jsx)(n.p,{children:"The OKP4 protocol enforces rules for governance and consent. When users want to do something in a Zone (launch a workflow to create new indicators or to train an AI model for instance), the protocol checks if it's allowed based on the rules. This decision considers the current situation, as the rules and digital resources on the blockchain are always changing. From a computer science perspective, the challenge is dealing with complex logic involving rules, such as hierarchy, inconsistency, and dependency.\nTo handle this, the OKP4 protocol ensures a secure and reliable way to interpret rules in a decentralized manner. The rules in each Zone and the consent attached to a resource determine if a user's action is permitted. It's important to keep in mind that this assessment also considers the evolving state of the blockchain at the time of the request."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"rules-1",src:s(15251).Z+"",width:"1494",height:"736"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"An Identity (human or bot) wants to interact with a Zone"}),"\n",(0,i.jsx)(n.li,{children:"The Zone asks the dedicated smart contract if it's possible given the context and all the involved rules"}),"\n",(0,i.jsx)(n.li,{children:"The protocol employs logical inference to resolve matters based on the state of the blockchain"}),"\n",(0,i.jsx)(n.li,{children:'The protocol yields a modality as a response, such as "prohibited", "permitted", "possible", and so on. Depending on the answer, the execution process could start.'}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"What kind of rules can be defined?"}),"\n",(0,i.jsx)(n.h3,{id:"1-defining-access-permissions",children:"1. Defining Access Permissions"}),"\n",(0,i.jsx)(n.p,{children:"One fundamental aspect of OKP4 rules is the ability to define access permissions. Through these rules, you can precisely outline who has the right to access specific off-chain resources. Whether it's granting read-only access to certain data or allowing full control over a particular resource, OKP4 empowers users to tailor access permissions according to their unique needs."}),"\n",(0,i.jsx)(n.h3,{id:"2-resource-utilization-policies",children:"2. Resource Utilization Policies"}),"\n",(0,i.jsx)(n.p,{children:"OKP4 goes beyond simple access permissions by allowing users to establish resource utilization policies. This involves defining how shared resources can be utilized, ensuring optimal efficiency and preventing misuse. Whether it's specifying the duration of resource access or setting usage quotas, OKP4 rules provide a flexible framework for resource management. For example, users can define temporal and spatial constraints for resource sharing. This means you can set rules that dictate when certain resources are available, creating dynamic access schedules. Additionally, spatial constraints enable the restriction of resource access based on geographical or network-specific parameters."}),"\n",(0,i.jsx)(n.h3,{id:"3-business-models",children:"3. Business models"}),"\n",(0,i.jsx)(n.p,{children:"Each zone can define how value is created and distributed among participants. This could range from straightforward transaction-based models to more complex, performance-based incentives."}),"\n",(0,i.jsx)(n.h3,{id:"4-dynamic-rule-updates",children:"4. Dynamic Rule Updates"}),"\n",(0,i.jsx)(n.p,{children:"The OKP4 protocol acknowledges the dynamic nature of resource management. Rules can be updated in real-time, enabling users to adapt to changing requirements seamlessly. This dynamicity ensures that OKP4 remains responsive to evolving scenarios, providing a future-proof solution for off-chain resource orchestration."}),"\n",(0,i.jsx)(n.h3,{id:"5-inter-rule-relationships",children:"5. Inter-Rule Relationships"}),"\n",(0,i.jsx)(n.p,{children:"OKP4 rules are not isolated entities; they can interact with one another. Understanding and defining inter-rule relationships is a powerful aspect of OKP4's flexibility. For example, you can establish dependencies between rules, ensuring that certain conditions must be met before others come into effect."}),"\n",(0,i.jsx)(n.p,{children:"The ability to define rules is a pivotal feature of the OKP4 protocol, offering an unprecedented level of control and customization. By leveraging these rules, participants can create a diverse range of applications and ecosystems, each with its unique governance and operational dynamics. This flexibility is central to OKP4\u2019s vision of fostering a decentralized, collaborative, and innovative digital resource environment."}),"\n",(0,i.jsx)(n.h2,{id:"prolog-turing-complete-logical-and-declarative-programming-language",children:"Prolog: Turing complete logical and declarative programming language"}),"\n",(0,i.jsx)(n.p,{children:"In the vast landscape of programming languages, Prolog stands out as a formidable tool, and in the realm of OKP4, it plays a pivotal role in shaping the logical and declarative aspects of the protocol. Prolog's significance lies in its ability to handle complex logical scenarios, making it a powerful choice for the dynamic environment of the OKP4 protocol."}),"\n",(0,i.jsx)(n.h3,{id:"1-the-essence-of-prolog",children:"1. The Essence of Prolog"}),"\n",(0,i.jsx)(n.p,{children:'Prolog, short for "Programming in Logic," is a unique programming paradigm that utilizes logical inference and declarative statements. Unlike traditional imperative languages, Prolog focuses on describing relationships and rules rather than explicit step-by-step instructions. This makes it well-suited for expressing complex relationships and solving intricate logical problems, precisely the kind of challenges faced in OKP4.'}),"\n",(0,i.jsx)(n.h3,{id:"2-turing-completeness",children:"2. Turing Completeness"}),"\n",(0,i.jsx)(n.p,{children:"One of Prolog's notable features is its Turing completeness. This term signifies that Prolog can, in theory, compute anything that is computable by other programming languages. This attribute is essential for OKP4, as it ensures that the logical and declarative programming capabilities provided by Prolog can address the diverse and evolving challenges presented by the combination of multiple resources and rules."}),"\n",(0,i.jsx)(n.h3,{id:"3-declarative-programming-in-action",children:"3. Declarative Programming in Action"}),"\n",(0,i.jsx)(n.p,{children:"In the context of OKP4, Prolog's declarative nature is a boon. Users can specify what they want to achieve, and Prolog handles the intricate task of determining how to achieve it. This allows to provide a clear and concise way to express the governance and consent rules that govern resource interactions."}),"\n",(0,i.jsx)(n.h3,{id:"4-logical-problem-solving",children:"4. Logical Problem Solving"}),"\n",(0,i.jsx)(n.p,{children:"The dynamic and evolving nature of OKP4's rules necessitates a robust logical problem-solving capability. Prolog excels in this arena by employing a resolution-based inference engine, allowing it to navigate through complex relationships defined by rules. This becomes crucial when resolving issues of hierarchy, inconsistency, dependency, and conflict resolution in the realm of access permissions and resource utilization."}),"\n",(0,i.jsx)(n.h3,{id:"5-decentralized-interpretation",children:"5. Decentralized Interpretation"}),"\n",(0,i.jsx)(n.p,{children:"In the OKP4 ecosystem, where decentralization is a key principle, Prolog is integrated in an on-chain module and serves as a trustworthy interpreter of rules. Each Zone, with its established rules, can leverage Prolog to determine the permissibility of a user's actions. This decentralized interpretation ensures that the governance and consent rules are applied consistently and reliably across the network."}),"\n",(0,i.jsx)(n.h3,{id:"6-prolog-in-practice",children:"6. Prolog in practice"}),"\n",(0,i.jsx)(n.p,{children:"Here are some fundamental concepts and basics of the Prolog language:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)("u",{children:"Declarative Style"}),":\nProlog is a declarative language, meaning that you specify what you want to achieve rather than how to achieve it. Programs in Prolog describe relationships and rules rather than a sequence of steps."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)("u",{children:"Logic Programming"}),":\nProlog is a logic programming language. It is based on the principles of first-order logic, where statements are represented as logical predicates."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)("u",{children:"Facts and Rules"}),":\nProlog programs consist of facts and rules. Facts are statements about the world, and rules define relationships and conditions. These are the building blocks for creating a knowledge base."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-prolog",children:"% Fact\n% John likes pizza.\nlikes(john, pizza).\n\n% Rule\n% X is hungry IF X likes pizza. \nhungry(X) :- likes(X, pizza).\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)("u",{children:"Predicates and Clauses"}),":\nIn Prolog, statements are expressed as predicates. Predicates consist of a function (name) and arguments. Clauses are the combination of facts and rules."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-prolog",children:"% Predicate\nlikes(john, pizza).\n\n% Clause (fact)\nfather(john, jim).\n\n% Clause (rule)\nsibling(X, Y) :- father(Z, X), father(Z, Y), X \\= Y.\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)("u",{children:"Variables"}),":\nProlog uses variables to represent unknown values. Variables are denoted with a capital letter or an underscore."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-prolog",children:"% Variable\n% John likes X.\nlikes(john, X).\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)("u",{children:"Queries"}),":\nProlog is interactive, and users can query the knowledge base. The system will attempt to find values for variables that satisfy the given conditions."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-prolog",children:"% Query\n% What does John like?\n?- likes(john, What).\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)("u",{children:"Backtracking"}),":\nProlog uses a backtracking mechanism to explore alternative solutions. If a query fails, Prolog will backtrack and explore other possibilities."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-prolog",children:"% Backtracking example\n% The following rule defines a family relationship.\nparent(john, jim).\nparent(john, ann).\nparent(jim, tom).\n\n% Query: Who is Tom's parent?\n?- parent(X, tom). \n% This will return X = jim, and upon backtracking, X = john.\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)("u",{children:"Recursion"}),":\nProlog supports recursion, allowing functions to call themselves. Recursive structures are common in Prolog for expressing relationships that involve repetition."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-prolog",children:"% Recursive rule for factorial\nfactorial(0, 1):-!.\nfactorial(N, Result) :- N > 0, Prev is N - 1, factorial(Prev, PrevResult), Result is N * PrevResult.\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)("u",{children:"Cut Operator (!)"}),":\nThe cut operator is used to control backtracking. It prunes the search space and commits Prolog to the choices made so far."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-prolog",children:"% Cut operator example\nlikes(john, pizza).\nlikes(john, sushi).\n\n% Query: Does John like pizza?\n?- likes(john, pizza), !.\n"})}),"\n",(0,i.jsx)(n.p,{children:"These are some of the basic concepts of Prolog. Its emphasis on logic and declarative programming makes it well-suited for applications involving rule-based systems, knowledge representation, and artificial intelligence."}),"\n",(0,i.jsx)(n.p,{children:"As we progress through the OKP4 Academy, the role of Prolog becomes increasingly apparent in enabling a Turing complete, logical, and declarative approach to managing the intricate rules that define the protocol. Join us on this journey as we explore the depth of Prolog's capabilities within the dynamic landscape of OKP4."}),"\n",(0,i.jsx)(n.h2,{id:"resources-consents",children:"Resource's consents"}),"\n",(0,i.jsx)(n.p,{children:"In the intricate web of the OKP4 protocol, the heartbeat of interaction lies within the rules governing each resource, also called consents. Understanding how these rules are defined and implemented is crucial for harnessing the true potential of OKP4's off-chain resource sharing."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"1. Defining Resource-Specific Rules"})}),"\n",(0,i.jsx)(n.p,{children:"Every resource within the OKP4 ecosystem comes with its own consent, a set of rules intricately defining how it can be accessed, utilized, and shared. These rules act as the blueprint for the resource's behavior, outlining the conditions under which it can be interacted with. Whether it's data, computational power, or any other off-chain asset, the rules serve as the guiding principles for their governance."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"2. Access Permissions and Restrictions"})}),"\n",(0,i.jsx)(n.p,{children:"At the core of resource consents are access permissions and restrictions. OKP4 allows resource owners to precisely dictate who can access their resources and under what circumstances. This includes specifying read or write permissions, setting limitations on the duration of access, and defining the geographical or network-based constraints for interaction. Such fine-grained control ensures that resource owners maintain sovereignty over their assets."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"3. Resource Utilization Policies"})}),"\n",(0,i.jsx)(n.p,{children:"Beyond mere access, OKP4 resource consents extend to resource utilization policies. Owners can define how their resources should be utilized, whether it's setting usage quotas, determining the conditions for resource sharing, or specifying the acceptable purposes for interaction. These policies contribute to the efficient and controlled utilization of resources within the decentralized OKP4 network."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"4. Dynamic Rule Adaptation"})}),"\n",(0,i.jsx)(n.p,{children:"Consents in OKP4 are not static; they adapt dynamically to the changing needs of the ecosystem. As conditions evolve, resource owners can update rules in real-time, ensuring that their assets remain responsive to the ever-shifting landscape of off-chain resource sharing. This dynamic adaptability is a key feature that aligns OKP4 with the fluid nature of decentralized networks."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"5. Rule Interdependencies and Conflicts"})}),"\n",(0,i.jsx)(n.p,{children:"Given the interconnected nature of resources and their rules, OKP4 acknowledges the potential for interdependencies and conflicts. The hierarchy of norms refers to the hierarchical structure of rules within the OKP4 governance framework. It establishes the order of precedence among the different norms so that a higher norm prevails over a lower standard. Then the rules of a Zone prevail on the resource consent (see technical doc)."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"rules-2",src:s(48845).Z+"",width:"1400",height:"657"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"6. Transparency and Auditing"})}),"\n",(0,i.jsx)(n.p,{children:"OKP4 places a premium on transparency in resource governance. Resource consents are designed to be transparent and auditable, allowing users and stakeholders to understand how each resource is governed. This transparency not only fosters trust but also contributes to the overall security and accountability within the OKP4 ecosystem."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"7. Let\u2019s practice"})}),"\n",(0,i.jsx)(n.p,{children:"Let's consider a simple example of rules written in Prolog for a hypothetical resource-sharing scenario within the OKP4 context. In this example, we'll create rules for granting access to a specific dataset based on user roles and temporal constraints."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-prolog",children:"% Define roles\nrole(admin).\nrole(user).\nrole(guest).\n\n% Define users and their roles\nuser_role(john, admin).\nuser_role(susan, user).\nuser_role(bob, guest).\n\n% Define access rules based on roles and time\naccess_rule(admin, Dataset, _):- dataset(Dataset).\naccess_rule(user, Dataset, Time):- dataset(Dataset), current_time(Time), Time < 18.00.\naccess_rule(guest, public_data, _).\n\n% Define the dataset\ndataset(confidential_data).\ndataset(public_data).\n\n% Simulate the current time (for illustration purposes)\ncurrent_time(15.30).\n\n% Example queries\n% Query: Can John access the confidential_data dataset at the current time?\n% Result: Yes, because John is an admin, and there's no temporal constraint for admins.\n?- user_role(john, Role), access_rule(Role, confidential_data, Time).\n\n% Query: Can Susan access the confidential_data dataset at the current time?\n% Result: Yes, because Susan is a user, and the current time is before 18.00.\n?- user_role(susan, Role), access_rule(Role, confidential_data, Time).\n\n% Query: Can Bob access the confidential_data dataset at the current time?\n% Result: No, because Bob is a guest, and the dataset is confidential with no specified temporal constraint for guests.\n?- user_role(bob, Role), access_rule(Role, confidential_data, Time).\n"})}),"\n",(0,i.jsx)(n.p,{children:"In this Prolog example:\nWe define roles (admin, user, guest) and associate users with roles.\nAccess rules are defined based on roles and, in some cases, temporal constraints. For instance, admins have unrestricted access to any dataset, users have access before 18.00, and guests have access to the public_data dataset without temporal constraints.\nWe define two datasets (confidential_data and public_data).\nThe current time is simulated to illustrate temporal constraints.\nExample queries demonstrate how Prolog can be used to check if a user has access to a specific dataset at the current time based on the defined rules.\nNote: The OKP4 SDK contains templates of governance rules that you can use and adapt to your needs."}),"\n",(0,i.jsx)(n.p,{children:"As we delve deeper into the OKP4 Academy, understanding the intricacies of resource rules becomes paramount. These rules serve as the backbone of the protocol, ensuring that off-chain resources are governed with precision, flexibility, and transparency. Join us as we unravel the complexities of resource rule management within the dynamic landscape of OKP4."})]})}function u(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},15251:(e,n,s)=>{s.d(n,{Z:()=>i});const i=s.p+"assets/images/rules-1-5dcbc47c61cb2699c0d72a3b5a26f6f9.webp"},48845:(e,n,s)=>{s.d(n,{Z:()=>i});const i=s.p+"assets/images/rules-2-7250d892179f44eb569b1e18677a3109.webp"},11151:(e,n,s)=>{s.d(n,{Z:()=>o,a:()=>r});var i=s(67294);const a={},t=i.createContext(a);function r(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);